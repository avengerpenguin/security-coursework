\documentclass{report}

\usepackage{listings}
\usepackage[style=authoryear,backend=biber]{biblatex}


\lstset{ %
  basicstyle=\footnotesize,
  breakatwhitespace=true,
  breaklines=true,
  extendedchars=true,
  frame=single,
  showspaces=false,
  showstringspaces=false
}

\title{Practical Security Log Book}
\author{Ross Fenning}

\bibliography{references}

\begin{document}

\maketitle
\tableofcontents

\chapter{Wireshark Analysis of a Teardrop attack}

In this report, we look at a very old attack at the IP layer
known as the \emph{Teardrop} attack which was able to crash
Linux and Windows computers at the time of discovery.
We also look at the protocol violation used to achieve this attack
in the \emph{Wireshark} analysis tool.

\section{What is a Teardrop attack?}

The Teardrop attack \parencite{center1997cert} was discovered
in late 1997 as a potential vulnerability in Windows 3.1x, Windows 95 and Windows NT
systems and versions of Linux prior to versions 2.0.32 and 2.1.63.
The vulnerability could allow a remote attacker to crash computers
running these systems due to a bug in the code performing IP fragmentation
reassembly.

IP fragmentation \parencite{postel1981rfc,fall2011tcp} is necessary if a router
receives a packet larger than the maximum transmission unit (MTU) of the
next hop. When this occurs, a router has the option to break the datagram
into smaller fragments. RFC 815 \parencite{clark1982ip} describes
an algorithm for how downstream hops can then reassemble the fragmented
IP packets.

The Teardrop attack involves sending fragmented IP packets such that the offset
of later packets do not correspond with the length of earlier packets. Normally,
if the first fragment is 16 bytes in size, then the second fragment should
indicate an offset of 16 bytes. Setting the second packet to a lower
offset such that the packets seem to overlap was known to cause bugs in
these old operating systems and thus they became vulnerable to the Teardrop
attack.

\section{Example}

Appendix~\ref{appendix:packets} shows raw exports from Wireshark of two frames
found in a capture of a Teardrop attack. We can see that Wireshark has identified
frames 8 and 9 as being two IP fragments which together make up a single UDP
packet.

The IPv4 header advertises a total length for the first fragment (frame 8)
of 56 bytes. The frame comprises 20 bytes for the IPv4 header and 36 bytes of
data. The bytes \texttt{00 38} at offset \texttt{0010} show this header length.
The third bit is set on the bytes \texttt{20 00}, which indicates more
fragments are to come, but this fragment starts at offset 0 (i.e. it's the first
fragment). This is a fairly standard initial fragment and there is nothing
malformed in this frame.

The attack comes in the next fragment (frame 9) where bytes \texttt{00 03}
claim that this fragment has an offset of 3 eight-byte blocks, or 24 bytes.
This is not in accord with the fact that the previous fragment was 36 bytes
long and looks as if this fragment overlaps the previous one.

Wireshark
has reassembled this to an IPv4 packet with 28 bytes of data as it has
resolved the malformed fragmentation by losing the last 12 bytes of the
first fragment (i.e. scrolling back to the advertised offset of 24 and
then adding on the 4 bytes contained in the second fragment). It has
also identified that the resulting 28 byte payload length does not
agree with the 36 byte header claimed in the UDP header (bytes \texttt{00 24}
at offset \texttt{0026}) and flagged that as an error.

The older versions of Windows and Linux were vulnerable to bugs in
their fragmentation reassembly that would simply cause the operating
systems to crash when this overlap occurred.

\chapter{GNU Privacy Guard}

In this report, we look at how to set up GNU Privacy Guard (GPG)
on a Debian or Ubuntu GNU/Linux
system although many of the steps apply to other Linux and Unix systems.
The steps outlined below will demonstrate how to:

\begin{enumerate}
\item generate a new private/public GPG key pair;
\item have a someone sign your new public key to verify that you own it;
\item use the public key to encrypt a plain text message; and
\item use the private key to decrypt the message.
\end{enumerate}

\section{Creating a GPG key pair}

The gpg tool is normally pre-installed in a lot of Linux/Unix systems as
tools like \texttt{apt} depend on it. On
a Debian or Ubuntu GNU/Linux system that does not have it installed, it
can be installed quite simply with:

\begin{lstlisting}
$ sudo apt-get install gnupg
[...]
$
\end{lstlisting}

We can run the command to see there are no keys already generated:

\begin{lstlisting}
$ gpg --list-keys
gpg: directory `/home/ross/.gnupg' created
gpg: new configuration file `/home/ross/.gnupg/gpg.conf' created
gpg: WARNING: options in `/home/ross/.gnupg/gpg.conf' are not yet active during this run
gpg: keyring `/home/ross/.gnupg/pubring.gpg' created
gpg: /home/ross/.gnupg/trustdb.gpg: trustdb created
$
\end{lstlisting}

Note that on the first use of the command, it creates some configuration files
and keyrings. If there were any keys already stored in the user's home
directory, then details of them would be printed out as well.

To create a key, we simply need to run:

\begin{lstlisting}
$ gpg --gen-key
gpg (GnuPG) 1.4.12; Copyright (C) 2012 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
Your selection? 1
RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (2048) 2048
Requested keysize is 2048 bits
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
Key is valid for? (0) 0
Key does not expire at all
Is this correct? (y/N) y

You need a user ID to identify your key; the software constructs the user ID
from the Real Name, Comment and Email Address in this form:
    "Heinrich Heine (Der Dichter) <heinrichh@duesseldorf.de>"

Real name: Ross Fenning
Email address: gpg@rossfenning.co.uk
Comment:
You selected this USER-ID:
    "Ross Fenning <gpg@rossfenning.co.uk>"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O
You need a Passphrase to protect your secret key.
[...]
gpg: key B8D85C76 marked as ultimately trusted
public and secret key created and signed.

gpg: checking the trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid: 1  signed: 0  trust: 0-, 0q, 0n, 0m, 0f, 1u
pub   4096R/B8D85C76 2014-12-14
      Key fingerprint = BDFD 1EF9 9052 4326 BA89  3897 30BC 9067 B8D8 5C76
uid                  Ross Fenning <gpg@rossfenning.co.uk>
sub   4096R/CEEFF134 2014-12-14
$
\end{lstlisting}

After answering all the questions and providing a passphrase,
you may be asked to generate some entropy.
Machines have a hard time using a good source of randomness to make sure
the key is not predictable and guessable, so you may be required to do
some work via keystrokes, mouse movements or run some processes that
do disk activity to generate some random events from which entropy
can be derived. Once this is complete, you will have your public and
private key pair.

To see the public key, enter:

\begin{lstlisting}
$ gpg --list-keys
/home/ross/.gnupg/pubring.gpg
-----------------------------
pub   4096R/B8D85C76 2014-12-14
uid                  Ross Fenning <gpg@rossfenning.co.uk>
sub   4096R/CEEFF134 2014-12-14
$
\end{lstlisting}

\noindent and to see the corresponding private key:

\begin{lstlisting}
$ gpg --list-secret-keys
/home/ross/.gnupg/secring.gpg
-----------------------------
sec   4096R/B8D85C76 2014-12-14
uid                  Ross Fenning <gpg@rossfenning.co.uk>
ssb   4096R/CEEFF134 2014-12-14
$
\end{lstlisting}

Note that the IDs (in our case B8D85C76) match on both the public
and private keys, which indicates they are a complementing pair.

\section{Distributing the public key}

After we have successfully created our key pair, we need to send
out our public key to people we know so that they may send
encrypted files or messages that only we can decrypt.

To export a public key into a file, do the following:

\begin{lstlisting}
$ gpg --output mypublickey.gpg --export B8D85C76
$
\end{lstlisting}

This creates a file called \texttt{mypublickey.gpg} which contains
a binary format of the key. This is suitable for sending as a file
(e.g. SCP, FTP or email attachment). Sometimes it may be more
convenient to export the key in ASCII for ease of pasting into emails
or instant messaging chats. To do this, we need to \emph{ASCII-armor}
the key thus:

\begin{lstlisting}
$ gpg --armor --export B8D85C76
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1.4.12 (GNU/Linux)

[...]
-----END PGP PUBLIC KEY BLOCK-----
$
\end{lstlisting}

The output from the previous command can be copied and pasted anywhere
you wish your key to be available. Either the binary form or the
ASCII-armored form of the key are safe to make available publicly for
anyone who wishes to send you encrypted messages.

Another party can then simply import your key:

\begin{lstlisting}
$ gpg --import mypublickey.pgp
gpg: key B8D85C76: public key "Ross Fenning <gpg@rossfenning.co.uk>" imported
gpg: Total number processed: 1
gpg:               imported: 1  (RSA: 1)
$
\end{lstlisting}

Once someone has your public key, they should verify it to ensure
it wasn't tampered and replaced in transit. To do this, the other
party would check your public key's fingerprint:

\begin{lstlisting}
$ gpg --fingerprint B8D85C76
pub   4096R/B8D85C76 2014-12-14
      Key fingerprint = BDFD 1EF9 9052 4326 BA89  3897 30BC 9067 B8D8 5C76
uid                  Ross Fenning <gpg@rossfenning.co.uk>
sub   4096R/CEEFF134 2014-12-14

$

\end{lstlisting}

The other person would then ask you to run the same command and confirm
over a different channel (e.g. a telephone call) that you both see
the same fingerprint. This is arguably the most important step to get
right as the security GPG brings is invalidated entirely if you
trust a key not genuinely created by it's reported owner.

Now the other party is happy they have imported your public key and
verified it is indeed your key in their possession, they are then
able to sign it:

\begin{lstlisting}
$ gpg --sign-key B8D85C76

pub  4096R/B8D85C76  created: 2014-12-14  expires: never       usage: SC  
                     trust: unknown       validity: unknown
sub  4096R/CEEFF134  created: 2014-12-14  expires: never       usage: E   
[ unknown] (1). Ross Fenning <gpg@rossfenning.co.uk>


pub  4096R/B8D85C76  created: 2014-12-14  expires: never       usage: SC  
                     trust: unknown       validity: unknown
 Primary key fingerprint: BDFD 1EF9 9052 4326 BA89  3897 30BC 9067 B8D8 5C76

     Ross Fenning <gpg@rossfenning.co.uk>

Are you sure that you want to sign this key with your
key "Other Party <other.party@example.com>" (164DFEEB)

Really sign? (y/N) y

You need a passphrase to unlock the secret key for
user: "Other Party <other.party@example.com>"
4096-bit RSA key, ID 12345678, created 2014-01-01

$
\end{lstlisting}

The other party is prompted for the passphrase of \emph{their} private key
which is then used to sign your public key within their keyring. This
tells their system that they vouch for that key. Typically, the other
party would then export your now-signed key again:

\begin{lstlisting}
$ gpg --output B8D85C76-signedby-12345678.gpg  --export B8D85C76
$
\end{lstlisting}

\noindent so that you can then import the signed version to replace your
unsigned one:

\begin{lstlisting}
$ gpg --import B8D85C76-signedby-12345678.gpg
gpg: key B8D85C76: "Ross Fenning <gpg@rossfenning.co.uk>" 1 new signature
gpg: Total number processed: 1
gpg:         new signatures: 1
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid: 1  signed: 0  trust: 0-, 0q, 0n, 0m, 0f, 1u
$
\end{lstlisting}

Note the ``1 new signature'' which shows your copy of your own public key
now includes a signature by the other party verifiying that they
believe that key is geuinely your public key. You can now export this
version of the key to other people and they may benefit from being able
to skip the step of verifying the fingerprint over the phone if they
can see your key is signed by another key they already trust.

This ``Web of Trust'' model is how GPG verifies identity and true ownership
of public keys.

\section{Encrypting a message}

Now that the other party has a copy of your public key and they are certain
that is really is your key, they can send encrypted files or messages to
you that only you may see.

For example, let us say they created a private message in a plain text file:

\begin{lstlisting}
$ echo "Hello" >secret.txt
$ cat secret.txt 
Hello
\end{lstlisting}

\noindent they are then able to encrypt this secret message so that only you may read it:

\begin{lstlisting}
$ gpg --recipient B8D85C76 --encrypt secret.txt
gpg: checking the trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid: 2  signed: 1  trust: 0-, 0q, 0n, 0m, 0f, 2u
gpg: depth: 1  valid: 1  signed: 0  trust: 1-, 0q, 0n, 0m, 0f, 0u
gpg: next trustdb check due at 2015-04-20
$ ls secret.txt*
secret.txt  secret.txt.gpg
\end{lstlisting}

Now we have the original message intact, but also an encrypted form of it.
Again, the \texttt{--armor} option would have created an ASCII form of
the encrypted message more suitable for pasting into emails (in a file
called \texttt{secret.txt.asc}).

\section{Decrypting the message}

The other party can then send the encrypted file or paste the ASCII version into
an email and then you can decrypt it:

\begin{lstlisting}
$ gpg --decrypt secret.txt.gpg

You need a passphrase to unlock the secret key for
user: "Ross Fenning <gpg@rossfenning.co.uk>"
4096-bit RSA key, ID CEEFF134, created 2014-12-14 (main key ID B8D85C76)

gpg: encrypted with 4096-bit RSA key, ID CEEFF134, created 2014-12-14
      "Ross Fenning <gpg@rossfenning.co.uk>"
Hello
$
\end{lstlisting}

\noindent and the ``Hello'' message is displayed. Note that you have to
provide your passphrase, which means your private key is involved in
decrypting the message. A malicious party would have to obtain both
your private key and the passphrase to use it in order to read this
encrypted message.

\chapter{Ethical Cracking Lab Setup}

In this report, we look at some tools that can be used to put together
a small lab setup for practising computer cracking and penetration
testing. This setup could also be used to observe and trace behaviours
of malware, e.g. viruses, but perhaps with a more stringent approach
to network isolation (see section~\ref{sec:netsec}).

The setup here is a network of virtual machines running under Virtualbox\footnote{https://www.virtualbox.org/}
running on a host computer that can be isolated if necessary. Once the
setup has been designed, we will look at using Vagrant\footnote{https://www.vagrantup.com/}
to make a repeatable
way of bootstrapping the lab on demand. This will help if we ever feel the
need to tear down the entire setup and start afresh or to share the
configuration with other researchers.

\section{Kali}

Kali\footnote{https://www.kali.org/}
is a GNU/Linux distribution based on Debian that comes with hundreds
of tools preinstalled that can be used in cracking and penetration testing. It
is available to download as an ISO CD image file which can easily be used
to install in a virtual machine using Virtualbox.

The Vagrantfile configuration in appendix~\ref{appendix:vagrant} shows a
simple provision of a Virtualbox instance of Kali from a pre-built
Vagrant box for convenience. For more control or more assurance about the
security of the virtual machine, it should be possible to fork and customise
the Packer build that created this image.\footnote{https://github.com/ctarwater/packer-kali}

\section{Metasploitable}

Metasploitable\footnote{http://sourceforge.net/projects/metasploitable/}
is a pre-built virtual machine from Rapid 7 to aid with learning
its penetration testing tool, Metasploit. We can equally make use of this
for learning Kali. As with Kali, we can add a configuration to our Vagrantfile
(appendix~\ref{appendix:vagrant}) for a pre-built box for convenience. Other
Packer-based builds are available on Github\footnote{https://github.com/waratek/vagrant-boxes}
if it is again preferred to have more control over the build.

\section{Vagrant}

As discussed in the previous two sections, vagrant provides us two conveniences
in building our lab setup:

\begin{enumerate}
\item Repeatable, refreshable and shareable builds of our whole lap setup. A whole classroom
  of lab setups for teaching could be running within an hour.
\item The ability to use pre-built box images, at least in the first instance, to get set up
  quickly, but still migrate to in-house builds of those images when the time is right.
\end{enumerate}

We can configure vagrant with the \emph{Vagrantfile} shown in appendix~\ref{appendix:vagrant},
which is a reasonably trivial configuration to bootstrap both Kali and Metasploitable on
the same private network. Note that the GUI is enabled so we can log in to X or a TTY
on either machine, which is required because the NAT adapter is overridden such that the
machines cannot communicate with the outside world. A side-effect of this is that
vagrant is unable to configure the network interfaces on the guest machines automatically
for us and we must edit \texttt{/etc/network/interfaces} ourselves, e.g.:

\begin{lstlisting}
iface eth0 inet static
    address 192.168.51.5
    netmask 255.255.255.0
\end{lstlisting}

The reasoning around this is discussed in section~\ref{sec:netsec}.

\section{Network Security}
\label{sec:netsec}

By overriding the NAT interface vagrant wants to use, we can enforce that
our lab network is only using a host-based adapter on a private network such
that the guests do not even have a gateway to the outside world. We can see
on the routing table that the guest only knows how to talk to the private
network:

\begin{lstlisting}
vagrant@metasploitable:~$ route
Kernel IP routing table
Destination   Gateway  Genmask        Flags Metric Ref  Use  Iface
192.168.51.0  *        255.255.255.0  U     0      0      0  eth0
vagrant@metasploitable:~$
\end{lstlisting}

For further security, it may be desirable to add iptables rules on the host
machine to drop any traffic that isn't going between the two defined
static IPs. This is perhaps an unnecessary step if we are only using the
penetration and exploit testing tools by hand and are in control of what
we are doing.

This lab setup can however be extended to include Windows
machines in the Vagrantfile such that we are able to examine malware and
viruses. If we are running malicious code (as opposed to simply running
exploitable services), then we likely want to make sure the host machine
is simply disconnected from any network and reinstall the whole host
before it is allowed back on any public network.

\printbibliography

\appendix

\chapter{Teardrop Attack Packets}
\label{appendix:packets}

\lstinputlisting[basicstyle=\scriptsize]{frame8.txt}
\pagebreak
\lstinputlisting[basicstyle=\scriptsize]{frame9.txt}

\chapter{Ethical Cracking Lab Vagrant Configuration}
\label{appendix:vagrant}

\lstinputlisting[basicstyle=\scriptsize,language=ruby]{networks/pentest/Vagrantfile}

\end{document}
